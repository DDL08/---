# 课设英汉电子词典

时间:2024-12

## 题目-17

```
问题描述：设计一个英汉电子词典，支持查找、插入、删除等功能。
基本要求：用AVL树去实现字典的基本操作，查找单词、插入单词（插入时，先查找，找不到则插入，找到则提示用户）、删除单词（删除时，先查找，找到则删除，找不到则提示用户）等。字典是按字母顺序排列的，不能用顺序查找，插入或删除单词后，要保持字典的有序性。
测试数据：任一英文单词。
基本要求：选用两种以上的数据结构实现字典的查找、插入、删除等操作
提示：字典可以自己建立，但必须按字母a~z建立26个文件，建议从网上下载，文件类型为txt。
```

## ALV树

在计算机科学中，**AVL树**（**Adelson-Velsky and Landis Tree**）是一种自平衡的二叉搜索树。它的特别之处在于，对于树中的每个节点，其左子树和右子树的高度差（称为**平衡因子**）不能大于1，否则需要进行旋转操作来恢复平衡。

## 参考资料

```
https://www.cnblogs.com/leipDao/p/10097001.html
```

## 字典

```
https://github.com/Longlong418/-Compact-English-Chinese-Dictionary/tree/master/word_source
```

## 函数调用关系图

![image-20241223093227121](https://github.com/DDL08/images/blob/img/img/image-20241223093227121.png?raw=true)

## python写法

+图形化界（未增加汉译英，因为他不要python写的）

```
import tkinter as tk
from tkinter import messagebox
import os

class AVLNode:
    def __init__(self, word, translation):
        self.word = word
        self.translation = translation
        self.left = None
        self.right = None
        self.height = 1 

class AVLTree:
    def __init__(self):
        self.root = None

    def get_height(self, node):
        if node is None:
            return 0
        return node.height

    def update_height(self, node):
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1

    def get_balance(self, node):
        if node is None:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)

    def right_rotate(self, y):
        x = y.left
        T2 = x.right
        # Perform rotation
        x.right = y
        y.left = T2
        # Update heights
        self.update_height(y)
        self.update_height(x)
        return x

    def left_rotate(self, x):
        y = x.right
        T2 = y.left
        # Perform rotation
        y.left = x
        x.right = T2
        # Update heights
        self.update_height(x)
        self.update_height(y)
        return y

    def insert(self, node, word, translation):
        # Perform standard BST insertion
        if node is None:
            return AVLNode(word, translation)

        if word < node.word:
            node.left = self.insert(node.left, word, translation)
        elif word > node.word:
            node.right = self.insert(node.right, word, translation)
        else:
            return node  # Duplicate words are not allowed

        self.update_height(node)
        balance = self.get_balance(node)

        # Balancing the node if it's unbalanced
        if balance > 1 and word < node.left.word:
            return self.right_rotate(node)

        if balance < -1 and word > node.right.word:
            return self.left_rotate(node)

        if balance > 1 and word > node.left.word:
            node.left = self.left_rotate(node.left)
            return self.right_rotate(node)

        if balance < -1 and word < node.right.word:
            node.right = self.right_rotate(node.right)
            return self.left_rotate(node)

        return node

    def search(self, node, word):
        if node is None or node.word == word:
            return node

        if word < node.word:
            return self.search(node.left, word)
        else:
            return self.search(node.right, word)

    def delete(self, node, word):
        if node is None:
            return node

        if word < node.word:
            node.left = self.delete(node.left, word)
        elif word > node.word:
            node.right = self.delete(node.right, word)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left

            # Node with two children: Get the inorder successor (smallest in the right subtree)
            min_node = self.get_min_value_node(node.right)
            node.word = min_node.word
            node.translation = min_node.translation
            node.right = self.delete(node.right, min_node.word)

        self.update_height(node)
        balance = self.get_balance(node)

        if balance > 1 and self.get_balance(node.left) >= 0:
            return self.right_rotate(node)

        if balance < -1 and self.get_balance(node.right) <= 0:
            return self.left_rotate(node)

        if balance > 1 and self.get_balance(node.left) < 0:
            node.left = self.left_rotate(node.left)
            return self.right_rotate(node)

        if balance < -1 and self.get_balance(node.right) > 0:
            node.right = self.right_rotate(node.right)
            return self.left_rotate(node)

        return node

    def get_min_value_node(self, node):
        if node is None or node.left is None:
            return node
        return self.get_min_value_node(node.left)
    
    def print_tree(self, node):
        if node is not None:
            self.print_tree(node.left)
            print(f"{node.word} - {node.translation}")
            self.print_tree(node.right)

def load_words_from_files(directory):
    tree = AVLTree()
    for letter in "abcdefghijklmnopqrstuvwxyz":
        file_path = os.path.join(directory, f"{letter}.txt")
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                lines = file.readlines()
                i = 0
                while i < len(lines):
                    word = lines[i].strip()
                    translation = lines[i+1].strip() if i+1 < len(lines) else ""
                    # 将单词和翻译插入到 AVL 树中
                    tree.root = tree.insert(tree.root, word, translation)
                    i += 2  # 跳过单词和翻译的下一行
    return tree

def save_tree_to_file(tree, directory):
    for letter in "abcdefghijklmnopqrstuvwxyz":
        file_path = os.path.join(directory, f"{letter}.txt")
        with open(file_path, 'w', encoding='utf-8') as file:
            _save_tree_to_file(tree.root, file, letter)

def _save_tree_to_file(node, file, letter):
    if node is not None:
        if node.word[0].lower() == letter:
            file.write(f"{node.word}\n=>{node.translation}\n")
        _save_tree_to_file(node.left, file, letter)
        _save_tree_to_file(node.right, file, letter)

class DictionaryApp:
    def __init__(self, root, dictionary, file_directory):
        self.root = root
        self.tree = dictionary
        self.file_directory = file_directory
        
        self.root.title("English-Chinese Dictionary")
        self.root.geometry("400x200")
        
        self.word_label = tk.Label(self.root, text="Enter Word:")
        self.word_label.pack()

        self.word_entry = tk.Entry(self.root)
        self.word_entry.pack()

        self.translation_label = tk.Label(self.root, text="Enter Translation:")
        self.translation_label.pack()

        self.translation_entry = tk.Entry(self.root)
        self.translation_entry.pack()

        self.search_button = tk.Button(self.root, text="Search", command=self.search_word)
        self.search_button.pack()

        self.insert_button = tk.Button(self.root, text="Insert", command=self.insert_word)
        self.insert_button.pack()

        self.delete_button = tk.Button(self.root, text="Delete", command=self.delete_word)
        self.delete_button.pack()

    def search_word(self):
        word = self.word_entry.get().strip()
        result = self.tree.search(self.tree.root, word)
        if result:
            messagebox.showinfo("Search Result", f"Word: {result.word}\nTranslation: {result.translation}")
        else:
            messagebox.showwarning("Not Found", f"Word '{word}' not found!")

    def insert_word(self):
        word = self.word_entry.get().strip()
        translation = self.translation_entry.get().strip()
        if not word or not translation:
            messagebox.showwarning("Invalid Input", "Please enter both word and translation.")
            return
        
        self.tree.root = self.tree.insert(self.tree.root, word, translation)
        save_tree_to_file(self.tree, self.file_directory)
        messagebox.showinfo("Success", f"Word '{word}' inserted!")

    def delete_word(self):
        word = self.word_entry.get().strip()
        if not word:
            messagebox.showwarning("Invalid Input", "Please enter a word to delete.")
            return
        
        result = self.tree.search(self.tree.root, word)
        if result:
            self.tree.root = self.tree.delete(self.tree.root, word)
            save_tree_to_file(self.tree, self.file_directory)
            messagebox.showinfo("Success", f"Word '{word}' deleted!")
        else:
            messagebox.showwarning("Not Found", f"Word '{word}' not found!")

if __name__ == "__main__":
    # Load the tree from files
    tree = load_words_from_files("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source")
    
    root = tk.Tk()
    app = DictionaryApp(root, tree, "C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source")
    root.mainloop()

```

## c++写法-失败

没写出来，觉得弄明白这个会浪费我很多时间，果断放弃

### qt库的安装

直接看下边资料吧

```
https://blog.csdn.net/qq_42257666/article/details/123285125

https://blog.csdn.net/zhanghm1995/article/details/102131347
```

为防止他撤稿，我简述如下

```
1.下载Windows的安装包 https://download.qt.io/archive/qt/5.12/5.12.6/
2.注册账户，点击安装Qt 5.12.6的MinGW 7.3.0 64-bit和Developer and Designer Tools 的Qt Creator 4.10.2 CDB Debugger Support
3.初学者用这俩够了，6个G多
4.用吧
```

qt库的GUI结构

这五个代码文件共同构成了一个简单的 Qt 应用程序，它们之间的关系和工作流程如下：

1. **`004.pro`**：这是 Qt 项目的项目文件，它定义了项目的配置和构建设置。
   - `QT += core gui`：指定项目使用 Qt 的核心模块和 GUI 模块。
   - `CONFIG += c++11`：设置编译器使用 C++11 标准。
   - `SOURCES`：列出项目的所有源代码文件。
   - `HEADERS`：列出项目的所有头文件。
   - `FORMS`：列出项目的所有 UI 设计文件（`.ui` 文件）。
   - `target.path`：定义应用程序的安装路径。

2. **`mainwindow.h`**：这是主窗口类的头文件。
   - 它声明了一个 `MainWindow` 类，该类继承自 `QMainWindow`。
   - `Q_OBJECT` 宏：使 `MainWindow` 类成为 Qt 的对象系统的一部分，允许使用 Qt 的信号和槽机制。
   - `Ui::MainWindow *ui;`：声明了一个指向 UI 类的指针，这个类是由 Qt Designer 自动生成的，包含了 UI 设计的所有元素。

3. **`main.cpp`**：这是应用程序的入口点。
   - 它包含了 `QApplication` 类的实例化，这是运行 Qt 应用程序所必需的。
   - 创建了 `MainWindow` 类的一个实例，并显示它。
   - 进入 Qt 的事件循环，等待用户操作。

4. **`mainwindow.cpp`**：这是主窗口类的实现文件。
   - 包含了 `MainWindow` 类的构造函数和析构函数。
   - 在构造函数中，它初始化了 UI 类（`ui`）并调用 `setupUi` 方法来设置窗口。
   - 析构函数中删除了 UI 类的实例，以防止内存泄漏。

5. **`mainwindow.ui`**：这是使用 Qt Designer 创建的 UI 设计文件。
   - 它定义了窗口的初始布局和控件。
   - 当你运行 `uic` 工具（Qt 的 UI 编译器）时，它会将 `.ui` 文件转换为对应的 C++ 头文件（`ui_mainwindow.h`），这个头文件包含了所有 UI 控件的实例。
   - 在 `mainwindow.cpp` 中，`ui` 指针被用来访问和操作这些控件。

工作流程：
1. `004.pro` 文件被 Qt 构建系统读取，以确定如何构建应用程序。
2. `main.cpp` 中的 `QApplication` 对象被创建，这是所有 Qt 应用程序的基础。
3. `MainWindow` 对象被创建，它加载了由 `mainwindow.ui` 文件定义的 UI 设计。
4. `MainWindow` 的 `show` 方法被调用，显示窗口。
5. Qt 的事件循环开始运行，等待用户输入和系统事件。
6. 用户与应用程序交互时，信号和槽机制响应事件，执行相应的槽函数。

通过这个结构，Qt 应用程序将 UI 设计、业务逻辑和事件处理分开，使得代码组织清晰，易于维护。

## java写法1.0

DictionaryApp.java

```
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.util.*;

public class DictionaryApp {

    // AVL Node class
    static class AVLNode {
        String word;
        String translation;
        AVLNode left, right;
        int height;

        public AVLNode(String word, String translation) {
            this.word = word;
            this.translation = translation;
            this.left = this.right = null;
            this.height = 1;
        }
    }

    // AVL Tree class
    static class AVLTree {
        private AVLNode root;

        public AVLTree() {
            root = null;
        }

        public int getHeight(AVLNode node) {
            return (node == null) ? 0 : node.height;
        }

        public void updateHeight(AVLNode node) {
            node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
        }

        public int getBalance(AVLNode node) {
            return (node == null) ? 0 : getHeight(node.left) - getHeight(node.right);
        }

        public AVLNode rightRotate(AVLNode y) {
            AVLNode x = y.left;
            AVLNode T2 = x.right;
            x.right = y;
            y.left = T2;
            updateHeight(y);
            updateHeight(x);
            return x;
        }

        public AVLNode leftRotate(AVLNode x) {
            AVLNode y = x.right;
            AVLNode T2 = y.left;
            y.left = x;
            x.right = T2;
            updateHeight(x);
            updateHeight(y);
            return y;
        }

        public AVLNode insert(AVLNode node, String word, String translation) {
            if (node == null) return new AVLNode(word, translation);

            if (word.compareTo(node.word) < 0) {
                node.left = insert(node.left, word, translation);
            } else if (word.compareTo(node.word) > 0) {
                node.right = insert(node.right, word, translation);
            } else {
                return node;  // Duplicate word not allowed
            }

            updateHeight(node);
            int balance = getBalance(node);

            // Balancing the tree
            if (balance > 1 && word.compareTo(node.left.word) < 0) {
                return rightRotate(node);
            }
            if (balance < -1 && word.compareTo(node.right.word) > 0) {
                return leftRotate(node);
            }
            if (balance > 1 && word.compareTo(node.left.word) > 0) {
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
            if (balance < -1 && word.compareTo(node.right.word) < 0) {
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }

            return node;
        }

        public AVLNode search(AVLNode node, String word) {
            if (node == null || node.word.equals(word)) {
                return node;
            }
            if (word.compareTo(node.word) < 0) {
                return search(node.left, word);
            } else {
                return search(node.right, word);
            }
        }

        public AVLNode delete(AVLNode node, String word) {
            if (node == null) {
                return node;
            }

            if (word.compareTo(node.word) < 0) {
                node.left = delete(node.left, word);
            } else if (word.compareTo(node.word) > 0) {
                node.right = delete(node.right, word);
            } else {
                if (node.left == null) {
                    return node.right;
                } else if (node.right == null) {
                    return node.left;
                }

                AVLNode minNode = getMinValueNode(node.right);
                node.word = minNode.word;
                node.translation = minNode.translation;
                node.right = delete(node.right, minNode.word);
            }

            updateHeight(node);
            int balance = getBalance(node);

            if (balance > 1 && getBalance(node.left) >= 0) {
                return rightRotate(node);
            }

            if (balance < -1 && getBalance(node.right) <= 0) {
                return leftRotate(node);
            }

            if (balance > 1 && getBalance(node.left) < 0) {
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }

            if (balance < -1 && getBalance(node.right) > 0) {
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }

            return node;
        }

        private AVLNode getMinValueNode(AVLNode node) {
            if (node == null || node.left == null) {
                return node;
            }
            return getMinValueNode(node.left);
        }

        public void saveTreeToFiles(String directory) {
            for (char letter = 'a'; letter <= 'z'; letter++) {
                String filePath = directory + "/" + letter + ".txt";
                try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath), "UTF-8"))) {
                    saveTreeToFile(root, writer, letter);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        private void saveTreeToFile(AVLNode node, BufferedWriter writer, char letter) throws IOException {
            if (node != null) {
                if (node.word.charAt(0) == letter) {
                    writer.write(node.word + "\n" + node.translation + "\n");
                }
                saveTreeToFile(node.left, writer, letter);
                saveTreeToFile(node.right, writer, letter);
            }
        }

        public AVLNode getRoot() {
            return root;
        }

        public void setRoot(AVLNode root) {
            this.root = root;
        }
    }

    // DictionaryApp GUI
    static class DictionaryAppGUI {
        private JFrame frame;
        private JTextField wordField, translationField;
        private AVLTree tree;

        public DictionaryAppGUI(AVLTree tree) {
            this.tree = tree;
            frame = new JFrame("English-Chinese Dictionary");
            frame.setSize(400, 200);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLayout(new FlowLayout());

            JLabel wordLabel = new JLabel("Enter Word:");
            wordField = new JTextField(20);
            JLabel translationLabel = new JLabel("Enter Translation:");
            translationField = new JTextField(20);

            JButton searchButton = new JButton("Search");
            searchButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    searchWord();
                }
            });

            JButton insertButton = new JButton("Insert");
            insertButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    insertWord();
                }
            });

            JButton deleteButton = new JButton("Delete");
            deleteButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    deleteWord();
                }
            });

            frame.add(wordLabel);
            frame.add(wordField);
            frame.add(translationLabel);
            frame.add(translationField);
            frame.add(searchButton);
            frame.add(insertButton);
            frame.add(deleteButton);
        }

        public void show() {
            frame.setVisible(true);
        }

        private void searchWord() {
            String word = wordField.getText().trim();
            AVLNode result = tree.search(tree.getRoot(), word);
            if (result != null) {
                JOptionPane.showMessageDialog(frame, "Word: " + result.word + "\nTranslation: " + result.translation);
            } else {
                JOptionPane.showMessageDialog(frame, "Word not found!", "Not Found", JOptionPane.WARNING_MESSAGE);
            }
        }

        private void insertWord() {
            String word = wordField.getText().trim();
            String translation = translationField.getText().trim();
            if (word.isEmpty() || translation.isEmpty()) {
                JOptionPane.showMessageDialog(frame, "Please enter both word and translation.", "Invalid Input", JOptionPane.WARNING_MESSAGE);
                return;
            }

            tree.setRoot(tree.insert(tree.getRoot(), word, translation));
            tree.saveTreeToFiles("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source");
            JOptionPane.showMessageDialog(frame, "Word '" + word + "' inserted!", "Success", JOptionPane.INFORMATION_MESSAGE);
        }

        private void deleteWord() {
            String word = wordField.getText().trim();
            if (word.isEmpty()) {
                JOptionPane.showMessageDialog(frame, "Please enter a word to delete.", "Invalid Input", JOptionPane.WARNING_MESSAGE);
                return;
            }

            AVLNode result = tree.search(tree.getRoot(), word);
            if (result != null) {
                tree.setRoot(tree.delete(tree.getRoot(), word));
                tree.saveTreeToFiles("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source");
                JOptionPane.showMessageDialog(frame, "Word '" + word + "' deleted!", "Success", JOptionPane.INFORMATION_MESSAGE);
            } else {
                JOptionPane.showMessageDialog(frame, "Word not found!", "Not Found", JOptionPane.WARNING_MESSAGE);
            }
        }
    }

    // Load words from files
    public static AVLTree loadWordsFromFiles(String directory) {
        AVLTree tree = new AVLTree();
        for (char letter = 'a'; letter <= 'z'; letter++) {
            String filePath = directory + "/" + letter + ".txt";
            File file = new File(filePath);
            if (file.exists()) {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"))) {
                    String word;
                    while ((word = reader.readLine()) != null) {
                        String translation = reader.readLine();
                        if (translation == null) translation = "";
                        tree.setRoot(tree.insert(tree.getRoot(), word, translation));
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return tree;
    }

    public static void main(String[] args) {
        AVLTree tree = loadWordsFromFiles("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source");
        DictionaryAppGUI app = new DictionaryAppGUI(tree);
        app.show();
    }
}

```

### 界面展示

#### 基础界面

##### 查询

![image-20241223115000109](https://github.com/DDL08/images/blob/img/img/image-20241223115000109.png?raw=true)

##### 基础界面

![image-20241223115102162](https://github.com/DDL08/images/blob/img/img/image-20241223115102162.png?raw=true)

##### 增加数据

![image-20241223115247980](https://github.com/DDL08/images/blob/img/img/image-20241223115247980.png?raw=true)

![image-20241223115335828](https://github.com/DDL08/images/blob/img/img/image-20241223115335828.png?raw=true)

##### 删除

![image-20241223115416137](https://github.com/DDL08/images/blob/img/img/image-20241223115416137.png?raw=true)

## java写法2.0

### 更新公告

- 将1.0版本进行优化，将弹窗形式改为显示数据
- 优化图形化界面

- 新增汉语查单词功能
- 新增模糊查找

### 代码部分

```
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.util.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.util.*;
import java.util.List;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.util.*;
public class bc {

    // AVL Node class
    static class AVLNode {
        String word;
        List<String> translations;
        AVLNode left, right;
        int height;

        public AVLNode(String word, List<String> translations) {
            this.word = word;
            this.translations = translations;
            this.left = this.right = null;
            this.height = 1;
        }
    }

    // AVL Tree class
    static class AVLTree {
        private AVLNode root;

        public AVLTree() {
            root = null;
        }

        public int getHeight(AVLNode node) {
            return node == null? 0 : node.height;
        }

        public void updateHeight(AVLNode node) {
            node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
        }

        public int getBalance(AVLNode node) {
            return node == null? 0 : getHeight(node.left) - getHeight(node.right);
        }

        public AVLNode rightRotate(AVLNode y) {
            AVLNode x = y.left;
            AVLNode T2 = x.right;
            x.right = y;
            y.left = T2;
            updateHeight(y);
            updateHeight(x);
            return x;
        }

        public AVLNode leftRotate(AVLNode x) {
            AVLNode y = x.right;
            AVLNode T2 = y.left;
            y.left = x;
            x.right = T2;
            updateHeight(x);
            updateHeight(y);
            return y;
        }

        public AVLNode insert(AVLNode node, String word, String translations) {
            if (node == null) return new AVLNode(word, Arrays.asList(translations.split(",")));

            if (word.compareTo(node.word) < 0) {
                node.left = insert(node.left, word, translations);
            } else if (word.compareTo(node.word) > 0) {
                node.right = insert(node.right, word, translations);
            } else {
                node.translations.addAll(Arrays.asList(translations.split(",")));
                return node;
            }

            updateHeight(node);
            int balance = getBalance(node);

            if (balance > 1 && word.compareTo(node.left.word) < 0) {
                return rightRotate(node);
            }
            if (balance < -1 && word.compareTo(node.right.word) > 0) {
                return leftRotate(node);
            }
            if (balance > 1 && word.compareTo(node.left.word) > 0) {
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
            if (balance < -1 && word.compareTo(node.right.word) < 0) {
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }

            return node;
        }

        public AVLNode search(AVLNode node, String word) {
            if (node == null || node.word.equals(word)) {
                return node;
            }
            if (word.compareTo(node.word) < 0) {
                return search(node.left, word);
            } else {
                return search(node.right, word);
            }
        }

        public List<String> searchByTranslation(AVLNode node, String translation) {
            List<String> matchingWords = new ArrayList<>();
            if (node!= null) {
                for (String trans : node.translations) {
                    if (trans.contains(translation)) {
                        matchingWords.add(node.word);
                        break;
                    }
                }
                matchingWords.addAll(searchByTranslation(node.left, translation));
                matchingWords.addAll(searchByTranslation(node.right, translation));
            }
            return matchingWords;
        }

        private AVLNode getMinValueNode(AVLNode node) {
            if (node == null || node.left == null) {
                return node;
            }
            return getMinValueNode(node.left);
        }

        public void saveTreeToFiles(String directory) {
            for (char letter = 'a'; letter <= 'z'; letter++) {
                String filePath = directory + "/" + letter + ".txt";
                try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath), "UTF-8"))) {
                    saveTreeToFile(root, writer, letter);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        private void saveTreeToFile(AVLNode node, BufferedWriter writer, char letter) throws IOException {
            if (node!= null) {
                if (node.word.charAt(0) == letter) {
                    writer.write(node.word + "\n" + String.join(",", node.translations) + "\n");
                }
                saveTreeToFile(node.left, writer, letter);
                saveTreeToFile(node.right, writer, letter);
            }
        }

        public AVLNode getRoot() {
            return root;
        }

        public void setRoot(AVLNode root) {
            this.root = root;
        }

        // 新增的删除节点方法
        public AVLNode delete(AVLNode root, String key) {
            if (root == null) {
                return root;
            }

            if (key.compareTo(root.word) < 0) {
                root.left = delete(root.left, key);
            } else if (key.compareTo(root.word) > 0) {
                root.right = delete(root.right, key);
            } else {
                if ((root.left == null) || (root.right == null)) {
                    AVLNode temp = root.left!= null? root.left : root.right;

                    if (temp == null) {
                        temp = root;
                        root = null;
                    } else {
                        root = temp;
                    }
                } else {
                    AVLNode temp = getMinValueNode(root.right);
                    root.word = temp.word;
                    root.translations = temp.translations;
                    root.right = delete(root.right, temp.word);
                }
            }

            if (root == null) {
                return root;
            }

            updateHeight(root);
            int balance = getBalance(root);

            if (balance > 1 && getBalance(root.left) >= 0) {
                return rightRotate(root);
            }

            if (balance > 1 && getBalance(root.left) < 0) {
                root.left = leftRotate(root.left);
                return rightRotate(root);
            }

            if (balance < -1 && getBalance(root.right) <= 0) {
                return leftRotate(root);
            }

            if (balance < -1 && getBalance(root.right) > 0) {
                root.right = rightRotate(root.right);
                return leftRotate(root);
            }

            return root;
        }

        // 获取以特定前缀开头的所有单词
        public List<String> getAllWordsWithPrefix(AVLNode node, String prefix) {
            List<String> result = new ArrayList<>();
            if (node!= null) {
                if (node.word.startsWith(prefix)) {
                    result.add(node.word);
                }
                result.addAll(getAllWordsWithPrefix(node.left, prefix));
                result.addAll(getAllWordsWithPrefix(node.right, prefix));
            }
            return result;
        }
    }

    // DictionaryApp GUI
    static class DictionaryAppGUI {
        private JFrame frame;
        private JTextField wordField, translationField;
        private JTextArea resultArea;
        private AVLTree tree;

        public DictionaryAppGUI(AVLTree tree) {
            this.tree = tree;
            frame = new JFrame("English-Chinese Dictionary");
            frame.setSize(600, 600);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLayout(new FlowLayout());

            JLabel wordLabel = new JLabel("Enter Word:");
            wordField = new JTextField(50);
            JLabel translationLabel = new JLabel("Enter Translation:");
            translationField = new JTextField(50);

            JButton searchButton = new JButton("Search");
            searchButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    searchWord();
                }
            });

            JButton insertButton = new JButton("Insert");
            insertButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    insertWord();
                }
            });

            JButton deleteButton = new JButton("Delete");
            deleteButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    deleteWord();
                }
            });
            

            JButton searchByTranslationButton = new JButton("Search by Translation");
            searchByTranslationButton.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    searchWordByTranslation();
                }
            });

            resultArea = new JTextArea(20, 50);
            resultArea.setEditable(false);
            JScrollPane scrollPane = new JScrollPane(resultArea);
            scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);

            frame.add(wordLabel);
            frame.add(wordField);
            //wordLabel.setPreferredSize(new Dimension(500, 50)); 
            wordLabel.setFont(new Font("Arial", Font.PLAIN, 30));
            wordField.setPreferredSize(new Dimension(400, 30));
            frame.add(translationLabel);
            frame.add(translationField);
            translationLabel.setFont(new Font("Arial", Font.PLAIN, 30)); 
            translationField.setPreferredSize(new Dimension(400, 30));
            frame.add(searchButton);
            frame.add(insertButton);
            frame.add(deleteButton);
            frame.add(searchByTranslationButton);
            searchButton.setPreferredSize(new Dimension(120, 40));
            deleteButton.setPreferredSize(new Dimension(120, 40));
            insertButton.setPreferredSize(new Dimension(120, 40));
            searchByTranslationButton.setPreferredSize(new Dimension(180, 40));
            frame.add(scrollPane);
        }

        public void show() {
            frame.setVisible(true);
        }

        private void searchWord() {
            String word = wordField.getText().trim();
            AVLNode result = tree.search(tree.getRoot(), word);
            StringBuilder resultText = new StringBuilder();
            List<String> prefixWords = tree.getAllWordsWithPrefix(tree.getRoot(), word);
        
            boolean exactMatch = false;
            for (String w : prefixWords) {
                if (w.equals(word)) {
                    AVLNode node = tree.search(tree.getRoot(), w);
                    if (node!= null) {
                        resultText.append("Word: ").append(w).append("\nTranslation: ").append(String.join(",", node.translations)).append("\n");
                        exactMatch = true;
                        break;
                    }
                }
            }
        
            if (!exactMatch) {
                resultText.append("Words with prefix '").append(word).append("':\n");
                for (String w : prefixWords) {
                    AVLNode node = tree.search(tree.getRoot(), w);
                    if (node!= null) {
                        resultText.append("Word: ").append(w).append("\nTranslation: ").append(String.join(",", node.translations)).append("\n");
                    }
                }
        
                if (result!= null) {
                    resultText.append("Word: ").append(result.word).append("\nTranslation: ").append(String.join(",", result.translations)).append("\n");
                } else {
                    resultText.append("Word not found!\n");
                }
            }
        
            resultArea.setText(resultText.toString());
        }

        private void insertWord() {
            String word = wordField.getText().trim();
            String translation = translationField.getText().trim();
            if (word.isEmpty() || translation.isEmpty()) {
                JOptionPane.showMessageDialog(frame, "Please enter both word and translation.", "Invalid Input", JOptionPane.WARNING_MESSAGE);
                return;
            }

            tree.setRoot(tree.insert(tree.getRoot(), word, translation));
            tree.saveTreeToFiles("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source");
            JOptionPane.showMessageDialog(frame, "Word '" + word + "' inserted!", "Success", JOptionPane.INFORMATION_MESSAGE);
        }

        private void deleteWord() {
            String word = wordField.getText().trim();
            if (word.isEmpty()) {
                JOptionPane.showMessageDialog(frame, "Please enter a word to delete.", "Invalid Input", JOptionPane.WARNING_MESSAGE);
                return;
            }

            AVLNode result = tree.search(tree.getRoot(), word);
            if (result!= null) {
                tree.setRoot(tree.delete(tree.getRoot(), word));
                tree.saveTreeToFiles("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source");
                JOptionPane.showMessageDialog(frame, "Word '" + word + "' deleted!", "Success", JOptionPane.INFORMATION_MESSAGE);
            } else {
                JOptionPane.showMessageDialog(frame, "Word not found!", "Not Found", JOptionPane.WARNING_MESSAGE);
            }
        }

        private void searchWordByTranslation() {
            String translation = translationField.getText().trim();
            List<String> resultWords = tree.searchByTranslation(tree.getRoot(), translation);
            StringBuilder resultText = new StringBuilder();
            if (resultWords.isEmpty()) {
                resultText.append("No words found for the translation!");
            } else {
                resultText.append("Words matching translation: \n");
                for (String word : resultWords) {
                    AVLNode node = tree.search(tree.getRoot(), word);
                    if (node!= null) {
                        resultText.append("Word: ").append(word).append("\nTranslation: ").append(String.join(",", node.translations)).append("\n");
                    }
                }
            }
            resultArea.setText(resultText.toString());
        }
    }

    // Load words from files
    public static AVLTree loadWordsFromFiles(String directory) {
        AVLTree tree = new AVLTree();
        for (char letter = 'a'; letter <= 'z'; letter++) {
            String filePath = directory + "/" + letter + ".txt";
            File file = new File(filePath);
            if (file.exists()) {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"))) {
                    String word;
                    while ((word = reader.readLine())!= null) {
                        String translation = reader.readLine();
                        if (translation == null) translation = "";
                        tree.setRoot(tree.insert(tree.getRoot(), word, translation));
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return tree;
    }

    public static void main(String[] args) {
        AVLTree tree = loadWordsFromFiles("C:/Users/LEGION/Desktop/新建文件夹/02/src/python-code/生成/课设17/word_source");
        DictionaryAppGUI app = new DictionaryAppGUI(tree);
        app.show();
    }}
```

### 界面展示

#### 基础界面

##### 查询

###### 绝对查询

![image-20241226183958763](https://github.com/DDL08/images/blob/img/img/image-20241226183958763.png?raw=true)

###### 模糊查找功能

在当准确查询没有查到的时候，会进行模糊查询

![image-20241226183914498](https://github.com/DDL08/images/blob/img/img/image-20241226183914498.png?raw=true)

#### 汉语查中文

![image-20241226184050806](https://github.com/DDL08/images/blob/img/img/image-20241226184050806.png?raw=true)
